from annotation.state import CODE_GAP


class Annotation:
    """
    Encapsulate sequence of states from HMM and provide its readable representation and filters
    """

    def __init__(self, read, states, skips, probability, motif):
        """
        :param read: Read - read to be annotated
        :type read: Read
        :param states: Sequence of states from HMM
        :param skips: For each subsequent pair of states, number of key states, that were skipped between them
        :param probability: Probability of generating sequence by the most likely sequence of HMM states
        :param motif: Sequence of tuples (sequence, repeats) as specified by user
        """

        # Store arguments into instance variables
        self.read = read
        self.states = states
        self.skips = skips
        self.probability = probability
        # self.motif = motif
        self.n_modules = len(motif)

        # Join subsequent states with number of deleted states between them
        self.subsequent_states = [(self.states[i], self.states[i + 1], self.skips[i])
                                  for i in range(len(self.states) - 1)]

        # Calculate number of insertions, deletions and normal bases
        self.n_insertions = sum([1 for state in self.states if state.is_insert()])
        self.n_deletions = sum(len(skip) for _, _, skip in self.subsequent_states)
        self.n_bases = len(self.read.sequence) - self.n_deletions

        # Generate gaped sequences and motifs for output
        self.ann_sequence, self.ann_quality = self.__get_ann_read()
        self.ann_motif, self.ann_module = self.__get_ann_motif()

        # Number of STR motif repetitions
        self.module_bases = self.__get_bases_per_module()
        self.module_repetitions = self.__get_module_repetitions()

        # get error line
        self.error_line, self.n_mismatches = self.__get_errors()

    def __str__(self):
        """
        Return the annotation.
        :return: str, str - annotation
        """
        return self.ann_sequence + '\n' + self.ann_motif + '\n' + self.ann_module + '\n' + self.error_line

    def __get_errors(self):
        """
        Count errors in annotation and the error line.
        :return: tuple(str, str) - error line and number of mismatches/SNPs
        """
        err_line = []
        mismatches = 0
        for mot, seq, module in zip(self.ann_motif.upper(), self.ann_sequence.upper(), self.ann_module):
            if mot == module or mot == seq:
                err_line.append('_')
            elif seq == '-':
                err_line.append('D')
            elif mot == '-':
                err_line.append('I')
            else:
                err_line.append('M')
                mismatches += 1

        return ''.join(err_line), mismatches

    def __get_ann_read(self):
        """
        :return: tuple(str, str) Input sequence and quality filled with gaps in deletion areas
        """
        seq, qual = [], []
        for nucleotide, phred, skip in zip(self.read.sequence, self.read.quality, self.skips):
            seq.append(nucleotide)
            qual.append(phred)
            for i in range(len(skip)):
                seq.append(CODE_GAP)
                qual.append(CODE_GAP)
        seq.append(self.read.sequence[-1])
        qual.append(self.read.quality[-1])
        return ''.join(seq), ''.join(qual)

    def __get_ann_motif(self):
        """
        :return: tuple(str, str) Motif sequence and module ids filled with skipped states in deletion areas
        """
        state_seq = []
        for from_state, to_state, skip in self.subsequent_states:
            state_seq.append(from_state)
            for s in skip:
                state_seq.append(s)
        state_seq.append(self.subsequent_states[-1][1])
        motif_seq = ''.join(str(state) for state in state_seq)
        module_seq = ''.join(str(state.module_id) for state in state_seq)
        return motif_seq, module_seq

    def __get_bases_per_module(self):
        """
        List of integers, each value corresponds to number of bases of input sequence that were generated by the module
        :return: Number of bases generated by each module
        """
        bases = [0] * self.n_modules
        for state in self.states:
            if state.is_key() or state.is_insert():
                bases[state.module_id] += 1
        return tuple(bases)

    def __get_module_repetitions(self):
        """
        List of integers, each value corresponds to number of repetitions of module in annotation
        :return: Number of repetitions generated by each module
        """
        repetitions = [0] * self.n_modules
        last_module_id = -1
        last_state_id = -1
        for i, state in enumerate(self.states):
            if not state.is_key():
                continue
            if state.module_id != last_module_id:
                # add repetition to the module (if its not the first and not starting:)
                if i != 0 or state.is_first_in_module():
                    repetitions[state.module_id] += 1
                last_module_id = state.module_id
            elif state.state_id <= last_state_id:
                # add repetition to module if the STR is repeated
                repetitions[state.module_id] += 1
            last_state_id = state.state_id
        # finally subtract one if the last one is not completed:
        state = self.states[-1]
        if not state.is_last_in_module() and repetitions[state.module_id] > 0:
            repetitions[state.module_id] -= 1

        return tuple(repetitions)

    def has_required_modules(self, required_repetitions):
        """
        Validate, if read is annotated with sufficient number of modules
        :param required_repetitions: list of number of required repetitions, one for each module
        :return: True, if annotation has required number of repetition for each module
        """
        if not required_repetitions:
            return True

        for repetition, required_repetition in zip(self.module_repetitions, required_repetitions):
            if repetition < required_repetition:
                return False
        return True

    def has_required_bases(self, required_bases):
        """
        Validate, if read bases are sufficiently annotated
        :param required_bases: list of number of required annotated bases, one for each module
        :return: True, if annotation has required number of annotated bases for each module
        """
        if not required_bases:
            return True

        for bases, required_base in zip(self.module_bases, required_bases):
            if bases < required_base:
                return False
        return True

    def has_one_primer(self, required_bases, required_repetitions, index_rep, index_rep2=None):
        """
        Validate, if at least one primer is sufficiently annotated, in case of 2 repetitions, we check only the
        :param required_bases: list of number of required annotated bases, one for each module
        :param required_repetitions: list of number of required annotated modules
        :param index_rep: int - index of the repetition, that we are looking at
        :param index_rep2: int - index of the second repetition, that we are looking at
        :return: True, if annotation has at least one primer is sufficiently annotated
        """
        # if it is not interesting just throw it away
        if not self.is_annotated_right():
            return False

        # if no filter, accept all
        if required_bases is None and required_repetitions is None:
            return True

        def check_reqs(index):
            """
            Check if requirements are met on 'index'
            :param index: int - index of a module
            :return: bool - requirements are met?
            """
            if required_bases is not None and self.module_bases[index] < required_bases[index]:
                return False
            if required_repetitions is not None and self.module_repetitions[index] < required_repetitions[index]:
                return False
            return True

        if index_rep2 is None:
            index_rep2 = index_rep
        index_rep, index_rep2 = min(index_rep, index_rep2), max(index_rep, index_rep2)

        # if the module has right primer and it is clipped on the left
        if index_rep2 + 1 < len(required_bases) and self.ann_module[0] != '-' and check_reqs(index_rep2 + 1) and check_reqs(index_rep):
            return True
        # if the module has left primer and it is clipped on the right
        if index_rep - 1 >= 0 and self.ann_module[-1] != '-' and check_reqs(index_rep - 1) and check_reqs(index_rep2):
            return True
        return False

    def has_less_errors(self, max_errors, relative=False):
        """
        Check if this annotation has less errors than max_errors. Make it relative to the annotated length if relative is set.
        :param max_errors: int/float - number of max_errors (relative if relative is set)
        :param relative: bool - if the errors are relative to the annotated length
        :return: bool - True if the number of errors is less than allowed
        """
        if max_errors is None:
            return True

        errors = self.n_deletions + self.n_insertions + self.n_mismatches
        if relative:
            return errors / float(sum(self.module_bases)) <= max_errors
        else:
            return errors <= max_errors

    def primers(self, index_rep):
        """
        Count how any primers it has on repetition index.
        :param index_rep: int - index of the repetition, that we are looking at
        :return: int - number of primers (0-2)
        """
        primers = 0
        if index_rep > 0 and self.module_repetitions[index_rep - 1] > 0:
            primers += 1
        if index_rep + 1 < len(self.module_repetitions) and self.module_repetitions[index_rep + 1] > 0:
            primers += 1
        return primers

    def is_annotated_right(self):
        """
        Is it annotated in a way that it is interesting? More than one module annotated + modules are not missing in the middle.
        :return: bool - annotated right?
        """

        # remove those that starts/ends in background but don't have a neighbour module
        starts_background = self.ann_module[0] == '-'
        ends_background = self.ann_module[-1] == '-'
        if starts_background and self.module_repetitions[0] == 0:
            return False
        if ends_background and self.module_repetitions[-1] == 0:
            return False

        # remove those with jumping modules
        started = False
        ended = False
        for repetition in self.module_repetitions:
            if repetition > 0:
                started = True
                if ended:
                    return False
            if repetition == 0 and started:
                ended = True

        # pass?
        return True

    def same_start_fragment(self, annotation):
        """
        Return True if both sequences can be produced from the same start of a fragment.
        :param annotation: Annotation - second annotation
        :return: bool - True if both sequences can be produced from the same start of a fragment
        """
        comp_length = min(len(self.read.sequence), len(annotation.read.sequence))
        return self.read.sequence[:comp_length] == annotation.read.sequence[:comp_length]

    def same_end_fragment(self, annotation):
        """
        Return True if both sequences can be produced from the same end of a fragment.
        :param annotation: Annotation | None - second annotation
        :return: bool - True if both sequences can be produced from the same end of a fragment
        """
        comp_length = min(len(self.read.sequence), len(annotation.read.sequence))
        return self.read.sequence[-comp_length:] == annotation.read.sequence[-comp_length:]

    def get_str_repetitions(self, index_str):
        """
        Get the number of str repetitions for a particular index.
        :param index_str: int - index of a str
        :return: (bool, int) - closed?, number of str repetitions
        """
        if self.is_annotated_right():
            primer1 = index_str > 0 and self.module_repetitions[index_str - 1] > 0
            primer2 = index_str + 1 < len(self.module_repetitions) and self.module_repetitions[index_str + 1] > 0
            if primer1 or primer2:
                return primer1 and primer2, self.module_repetitions[index_str]
        return None
